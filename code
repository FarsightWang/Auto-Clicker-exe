import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import threading
from selenium import webdriver
from selenium.webdriver.edge.service import Service as EdgeService
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.firefox.service import Service as FirefoxService
from selenium.webdriver.edge.options import Options as EdgeOptions
from selenium.webdriver.chrome.options import Options as ChromeOptions
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from webdriver_manager.microsoft import EdgeChromiumDriverManager
from webdriver_manager.chrome import ChromeDriverManager
from webdriver_manager.firefox import GeckoDriverManager
import time
from collections import defaultdict
import logging
import queue
import traceback

class AutoClickerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("多瀏覽器自動點擊器")
        self.root.geometry("800x600")
        
        # 設置日誌
        self.setup_logging()
        
        # 創建主框架
        self.create_main_frame()
        
        # 初始化變量
        self.is_running = False
        self.click_thread = None
        self.log_queue = queue.Queue()
        
        # 定期更新日誌
        self.root.after(100, self.update_log)

    def setup_logging(self):
        """設置日誌系統"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s: %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        self.logger = logging.getLogger(__name__)

    def create_main_frame(self):
        """創建主界面佈局"""
        # URL 輸入區
        url_frame = ttk.LabelFrame(self.root, text="網址設定")
        url_frame.pack(padx=10, pady=10, fill='x')
        
        url_label = ttk.Label(url_frame, text="請輸入網址（每行一個）:")
        url_label.pack(anchor='w', padx=5, pady=5)
        
        self.url_text = scrolledtext.ScrolledText(
            url_frame, 
            height=5, 
            width=80
        )
        self.url_text.pack(padx=5, pady=5)

        # 設置區
        setting_frame = ttk.LabelFrame(self.root, text="點擊設定")
        setting_frame.pack(padx=10, pady=10, fill='x')
        
        # 瀏覽器選擇
        browser_frame = ttk.Frame(setting_frame)
        browser_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Label(browser_frame, text="選擇瀏覽器:").pack(side='left', padx=5)
        self.browser_var = tk.StringVar(value="Edge")
        browser_combo = ttk.Combobox(
            browser_frame, 
            textvariable=self.browser_var, 
            values=["Edge", "Chrome", "Firefox"],
            state="readonly",
            width=10
        )
        browser_combo.pack(side='left', padx=5)

        # 點擊次數
        clicks_frame = ttk.Frame(setting_frame)
        clicks_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Label(clicks_frame, text="點擊次數:").pack(side='left', padx=5)
        self.clicks_var = tk.StringVar(value="200")
        clicks_entry = ttk.Entry(clicks_frame, textvariable=self.clicks_var, width=10)
        clicks_entry.pack(side='left', padx=5)

        # 影片播放時間
        time_frame = ttk.Frame(setting_frame)
        time_frame.pack(fill='x', padx=5, pady=5)
        
        ttk.Label(time_frame, text="影片播放時間(秒):").pack(side='left', padx=5)
        self.time_var = tk.StringVar(value="3")
        time_entry = ttk.Entry(time_frame, textvariable=self.time_var, width=10)
        time_entry.pack(side='left', padx=5)

        # 控制按鈕
        button_frame = ttk.Frame(self.root)
        button_frame.pack(padx=10, pady=10)
        
        self.start_button = ttk.Button(
            button_frame, 
            text="開始執行", 
            command=self.start_clicking
        )
        self.start_button.pack(side='left', padx=5)
        
        self.stop_button = ttk.Button(
            button_frame, 
            text="停止", 
            command=self.stop_clicking,
            state='disabled'
        )
        self.stop_button.pack(side='left', padx=5)

        # 日誌區域
        log_frame = ttk.LabelFrame(self.root, text="執行日誌")
        log_frame.pack(padx=10, pady=10, fill='both', expand=True)
        
        self.log_text = scrolledtext.ScrolledText(
            log_frame, 
            height=10, 
            width=80
        )
        self.log_text.pack(padx=5, pady=5)

    def create_driver(self, browser):
        """根據選擇的瀏覽器創建驅動"""
        try:
            if browser == "Edge":
                options = EdgeOptions()
                options.add_argument('--disable-gpu')
                return webdriver.Edge(
                    service=EdgeService(EdgeChromiumDriverManager().install()),
                    options=options
                )
            elif browser == "Chrome":
                options = ChromeOptions()
                options.add_argument('--disable-gpu')
                return webdriver.Chrome(
                    service=ChromeService(ChromeDriverManager().install()),
                    options=options
                )
            elif browser == "Firefox":
                options = FirefoxOptions()
                options.add_argument('--disable-gpu')
                return webdriver.Firefox(
                    service=FirefoxService(GeckoDriverManager().install()),
                    options=options
                )
        except Exception as e:
            self.log_message(f"創建驅動失敗: {e}")
            return None

    def start_clicking(self):
        """開始點擊"""
        # 驗證輸入
        urls = [url.strip() for url in self.url_text.get("1.0", tk.END).split("\n") if url.strip()]
        if not urls:
            messagebox.showerror("錯誤", "請輸入至少一個網址")
            return

        try:
            target_clicks = int(self.clicks_var.get())
            video_time = int(self.time_var.get())
        except ValueError:
            messagebox.showerror("錯誤", "請輸入有效的數字")
            return

        # 更新UI狀態
        self.start_button.config(state='disabled')
        self.stop_button.config(state='normal')
        self.is_running = True

        # 創建並啟動線程
        self.click_thread = threading.Thread(
            target=self.clicking_thread, 
            args=(urls, target_clicks, video_time),
            daemon=True
        )
        self.click_thread.start()

    def clicking_thread(self, urls, target_clicks, video_time):
        """點擊執行線程"""
        try:
            browser = self.browser_var.get()
            driver = self.create_driver(browser)
            
            if not driver:
                self.log_message("無法創建瀏覽器驅動，程序終止")
                self.reset_ui()
                return

            click_counts = defaultdict(int)
            total_clicks_needed = len(urls) * target_clicks
            total_clicks_done = 0

            while self.is_running:
                if all(click_counts[url] >= target_clicks for url in urls):
                    self.log_message("所有網址都已達到目標點擊數！")
                    break

                for url in urls:
                    if not self.is_running:
                        break

                    if click_counts[url] >= target_clicks:
                        continue

                    try:
                        self.log_message(f"正在訪問: {url}")
                        driver.get(url)
                        click_counts[url] += 1
                        total_clicks_done += 1

                        self.log_message(
                            f"進度: {total_clicks_done}/{total_clicks_needed} "
                            f"({total_clicks_done/total_clicks_needed*100:.1f}%)"
                        )

                        time.sleep(video_time)

                    except Exception as e:
                        self.log_message(f"訪問網址時發生錯誤: {e}")
                        try:
                            driver.quit()
                        except:
                            pass
                        driver = self.create_driver(browser)

        except Exception as e:
            self.log_message(f"發生未預期的錯誤: {e}")
            traceback.print_exc()
        finally:
            if driver:
                try:
                    driver.quit()
                except:
                    pass
            self.reset_ui()

    def stop_clicking(self):
        """停止點擊"""
        self.is_running = False
        self.log_message("正在停止...")
        self.stop_button.config(state='disabled')

    def reset_ui(self):
        """重置UI狀態"""
        self.root.after(0, lambda: self.start_button.config(state='normal'))
        self.root.after(0, lambda: self.stop_button.config(state='disabled'))

    def log_message(self, message):
        """記錄日誌"""
        self.log_queue.put(message)

    def update_log(self):
        """定期更新日誌"""
        try:
            while True:
                message = self.log_queue.get_nowait()
                self.log_text.insert(tk.END, message + "\n")
                self.log_text.see(tk.END)
        except queue.Empty:
            pass
        
        self.root.after(100, self.update_log)

def main():
    root = tk.Tk()
    app = AutoClickerApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()
